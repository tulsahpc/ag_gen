exploit moveBladeUpDesync1_0(blade,controlRodController)=
	preconditions:
		quality: controlRodController, platform=controlRodController;
		quality: blade, platform=controlBlade;

		quality: controlRodController, status=compromised;
		quality: controlRodController, powerStatus=on;
		quality: controlRodController, emagPower=on;

		quality: blade, actualPosition<1; #Max position
		quality: blade, motorStatus=ok;
	postconditions:
		update quality: blade, actualPosition+=.5;
.

exploit moveBladeUpDesync1_1(blade,controlRodController)=
	preconditions:
		quality: controlRodController, platform=controlRodController;
		quality: blade, platform=pulseControlRod;

		quality: controlRodController, status=compromised;
		quality: controlRodController, powerStatus=on;
		quality: controlRodController, emagPower=on;

		quality: blade, actualPosition<1; #Max position
		quality: blade, motorStatus=ok;
	postconditions:
		update quality: blade, actualPosition+=.5;
.

exploit moveBladeUpDesync2_1(blade,controlRodController, operator)=
	preconditions:
		quality: controlRodController, platform=controlRodController;
		quality:operator,platform=operatorStation;
		quality: blade, platform=pulseControlRod;

		topology: controlRodController!>operator,connected_modbus_slave;

		quality: controlRodController, powerStatus=on;
		quality: controlRodController, emagPower=on;

		quality: blade, actualPosition<1; #Max position
		quality: blade, motorStatus=ok;
	postconditions:
		update quality: blade, actualPosition+=.5;
.

exploit moveBladeUpDesync2_2(blade,controlRodController, operator)=
	preconditions:
		quality: controlRodController, platform=controlRodController;
		quality:operator,platform=operatorStation;
		quality: blade, platform=pulseControlRod;

		topology: operator!>controlRodController,connected_modbus_master;

		quality: controlRodController, powerStatus=on;
		quality: controlRodController, emagPower=on;

		quality: blade, actualPosition<1; #Max position
		quality: blade, motorStatus=ok;
	postconditions:
		update quality: blade, actualPosition+=.5;
.

exploit moveBladeUpDesync2_3(blade,controlRodController, operator)=
	preconditions:
		quality: controlRodController, platform=controlRodController;
		quality:operator,platform=operatorStation;
		quality: blade, platform=controlBlade;

		topology: controlRodController!>operator,connected_modbus_slave;

		quality: controlRodController, powerStatus=on;
		quality: controlRodController, emagPower=on;

		quality: blade, actualPosition<1; #Max position
		quality: blade, motorStatus=ok;
	postconditions:
		update quality: blade, actualPosition+=.5;
.

exploit moveBladeUpDesync2_4(blade,controlRodController, operator)=
	preconditions:
		quality: controlRodController, platform=controlRodController;
		quality:operator,platform=operatorStation;
		quality: blade, platform=controlBlade;

		topology: operator!>controlRodController,connected_modbus_master;

		quality: controlRodController, powerStatus=on;
		quality: controlRodController, emagPower=on;

		quality: blade, actualPosition<1; #Max position
		quality: blade, motorStatus=ok;
	postconditions:
		update quality: blade, actualPosition+=.5;
.

# exploit dosScramSensor(sensor, automaticScram)=
	# preconditions:
		# quality: automaticScram,platform=scramUnit;
		# topology: sensor->automaticScram,connected_modbus_slave;
		# topology: automaticScram->sensor,connected_modbus_master;
	# postconditions:
		# delete topology: sensor->automaticScram,connected_modbus_slave;
		# delete topology: automaticScram->sensor,connected_modbus_master;
		# #Does not trigger scram, this is handled by another exploit

# .

exploit dosOperatorSensor(sensor, operator)=
	preconditions:
		#Limiter
		quality: sensor, platform=controlRodController;

		quality: operator, platform=operatorStation;
		topology: sensor->operator,connected_modbus_slave;
		topology: operator->sensor,connected_modbus_master;
	postconditions:
		delete topology: sensor->operator,connected_modbus_slave;
		delete topology: operator->sensor,connected_modbus_master;
		#Does not trigger scram
.

exploit tempScram(sensor, automaticScram, controlRodController)=

	preconditions:
        quality:sensor,platform=tempSensor;
		quality:sensor,powerStatus=on;
        quality:sensor,temp>471;

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: sensor->automaticScram,connected_modbus_slave;
		topology: automaticScram->sensor,connected_modbus_master;
    postconditions:
        update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit seismicScram(sensor,automaticScram, controlRodController)=

	preconditions:
		quality:sensor,platform=seismicSensor;
		quality:sensor,powerStatus=on;
		quality:sensor,magnitude>.0061;

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: sensor->automaticScram,connected_modbus_slave;
		topology: automaticScram->sensor,connected_modbus_master;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit highFluxScram(sensor,automaticScram, controlRodController)=

	preconditions:
		quality:sensor,platform=fluxMonitor;
		quality:sensor,powerStatus=on;
		quality:sensor,alarmActivated=true;

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,mode!=pulse;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: sensor->automaticScram,connected_modbus_slave;
		topology: automaticScram->sensor,connected_modbus_master;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit buildingEvacScram(evacAlarm,automaticScram, controlRodController)=

	preconditions:
		quality:evacAlarm,platform=evacuationAlarm;
		quality:evacAlarm,activated=true;
		quality:evacAlarm,powerStatus=on;

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: evacAlarm->automaticScram,connected_modbus_slave;
		topology: automaticScram->evacAlarm,connected_modbus_master;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit manualBeamRoomScram(beamRoom,automaticScram, controlRodController)=

	preconditions:
		quality:beamRoom,platform=scramInput;
		quality:beamRoom,activated=true;
		quality:beamRoom,powerStatus=on;

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: beamRoom->automaticScram,connected_modbus_slave;
		topology: automaticScram->beamRoom,connected_modbus_master;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit manualScram(operator,automaticScram, controlRodController)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,manualScram=true;
		quality:operator,powerStatus=on;

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology:operator->automaticScram,connected_modbus_slave;
		topology:automaticScram->operator,connected_modbus_master;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit HVSensorScram(sensor, automaticScram, controlRodController)=

	preconditions:
		quality:sensor,platform=HVSensor;
		quality:sensor,activated=true;
		quality:sensor,powerStatus=on;

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: sensor->automaticScram,connected_modbus_slave;
		topology: automaticScram->sensor,connected_modbus_master;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit sensorMissingScram_1(sensor, automaticScram, controlRodController)=

	preconditions:
		quality:sensor,platform=tempSensor;

		#quality:sensor,spoofed=false; #Not currenly avalible in simulation

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: sensor!>automaticScram,connected_modbus_slave;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit sensorMissingScram_2(sensor, automaticScram, controlRodController)=

	preconditions:
		quality:sensor,platform=seismicSensor;

		#quality:sensor,spoofed=false; #Not currenly avalible in simulation

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: sensor!>automaticScram,connected_modbus_slave;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit sensorMissingScram_3(sensor, automaticScram, controlRodController)=

	preconditions:
		quality:sensor,platform=fluxMonitor;

		#quality:sensor,spoofed=false; #Not currenly avalible in simulation

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: sensor!>automaticScram,connected_modbus_slave;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit sensorMissingScram_4(sensor, automaticScram, controlRodController)=

	preconditions:
		quality:sensor,platform=tempSensor;

		#quality:sensor,spoofed=false; #Not currenly avalible in simulation

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: automaticScram!>sensor,connected_modbus_master;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit sensorMissingScram_5(sensor, automaticScram, controlRodController)=

	preconditions:
		quality:sensor,platform=seismicSensor;

		#quality:sensor,spoofed=false; #Not currenly avalible in simulation

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: automaticScram!>sensor,connected_modbus_master;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

exploit sensorMissingScram_6(sensor, automaticScram, controlRodController)=

	preconditions:
		quality:sensor,platform=fluxMonitor;

		#quality:sensor,spoofed=false; #Not currenly avalible in simulation

		quality:automaticScram,platform=scramUnit;
		quality:automaticScram,status=ok;
		quality:automaticScram,powerStatus=on;
		quality:automaticScram,activated=false;#prevent self-loops

		quality:controlRodController,platform=controlRodController;
		topology: automaticScram->controlRodController,connected_emag_power;

		topology: automaticScram!>sensor,connected_modbus_master;
	postconditions:
		update quality:automaticScram,activated=true;
		update quality:controlRodController,emagPower=off;
		delete topology:automaticScram->controlRodController,connected_emag_power;
.

#Execute Scram rolled into triggering events.

#Finishes perfoming the scram by dropping blades into the reactor
#Accounts for blade 5 being unscrammable.
# (This is 2 steps)
exploit dropBlades1(controlRodController, blade)=

	preconditions:
        quality:controlRodController,platform=controlRodController;
		quality:blade,platform=controlBlade;
		quality:blade,scrammable=true;

		quality:controlRodController,emagPower=off;

		topology:blade->controlRodController,subcomponent;
    postconditions:
        update quality:blade,actualPosition:=0;
		#Should reported position be updated?
.

exploit dropBlades2(controlRodController, blade)=

	preconditions:
        quality:controlRodController,platform=controlRodController;
		quality:blade,platform=pulseControlRod;

		quality:controlRodController,emagPower=off;

		topology:blade->controlRodController,subcomponent;
    postconditions:
        update quality:blade,actualPosition:=0;
		#Should reported position be updated?
.

#Attempting to model operator's reactive behavior. All of these are called "Shutdown"
#These are slower than scrams, and are in the group time2
#Technically in the model they still activate a scram for simplicity at the moment.
exploit coolantLossShutdown(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=coolantLevelSensor;
		quality:sensor,powerStatus=on;
		quality:sensor,level<-8.0;

		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit coolantTempShutdown(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=coolantTempSensor;
		quality:sensor,powerStatus=on;
		quality:sensor,temp>50;#***Somewhat Arbitrary

		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit fuelTempShutdown(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=tempSensor;
		quality:sensor,temp>375;#***Somewhat Arbitrary
		quality:sensor,powerStatus=on;

		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

#Not sure how to go about adding this one, flux vs power
exploit powerLevelShutdown(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=powerSensor;
		quality:sensor,powerLevel>1.01;#*******Arbitrary
		quality:sensor,powerStatus=on;

		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit CAMShutdown(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=CAM;
		quality:sensor,alarmActivated=true;
		quality:sensor,powerStatus=on;

		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit areaMonitoringSystemShutdown_1(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=N16Detector;
		quality:sensor,powerStatus=on;

		#mrem/hr for all, Arbitriaily 90% of alarm levels
		quality: sensor, cave_N16_level>45;


		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit areaMonitoringSystemShutdown_2(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=N16Detector;
		quality:sensor,powerStatus=on;

		#mrem/hr for all, Arbitriaily 90% of alarm levels
		quality: sensor, nBeamRoom_N16_level>9;


		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit areaMonitoringSystemShutdown_3(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=N16Detector;
		quality:sensor,powerStatus=on;

		#mrem/hr for all, Arbitriaily 90% of alarm levels
		quality: sensor, sBeamRoom_N16_level>9;


		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit areaMonitoringSystemShutdown_4(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=N16Detector;
		quality:sensor,powerStatus=on;

		#mrem/hr for all, Arbitriaily 90% of alarm levels
		quality: sensor, sample_N16_level>90;


		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit areaMonitoringSystemShutdown_5(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=N16Detector;
		quality:sensor,powerStatus=on;

		#mrem/hr for all, Arbitriaily 90% of alarm levels
		quality: sensor, bridge_N16_level>90;


		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit areaMonitoringSystemShutdown_6(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=N16Detector;
		quality:sensor,powerStatus=on;

		#mrem/hr for all, Arbitriaily 90% of alarm levels
		quality: sensor, room101_N16_level>9;

		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit ventilationAirDetectorShutdown(operator,sensor)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:sensor,platform=Ar41Detector;
		quality:sensor,alarmActivated=true;
		quality:sensor,powerStatus=on;

		topology:sensor->operator,connected_modbus_slave;
		topology:operator->sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.


exploit coolantLeakShutdown(operator, conductivityCell3)=

	preconditions:
		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;
		quality:operator,manualScram=false;#prevent self-loops

		quality:conductivityCell3,platform=conductivitySensor;
		quality:conductivityCell3,conductivity>=1.25;# micromho/cm
		quality:conductivityCell3,powerStatus=on;

		topology:conductivityCell3->operator,connected_modbus_slave;
		topology:operator->conductivityCell3,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

#Using asset operator here since a fake operator doesn't need to see this information
exploit sensorMissingShutdown_1(sensor, operator)=

	preconditions:
		quality:sensor,platform=tempSensor;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: sensor!>operator,connected_modbus_slave;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_2(sensor, operator)=

	preconditions:
		quality:sensor,platform=coolantTempSensor;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: sensor!>operator,connected_modbus_slave;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_3(sensor, operator)=

	preconditions:
		quality:sensor,platform=powerSensor;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: sensor!>operator,connected_modbus_slave;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_4(sensor, operator)=

	preconditions:
		quality:sensor,platform=CAM;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: sensor!>operator,connected_modbus_slave;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_5(sensor, operator)=

	preconditions:
		quality:sensor,platform=periodSensor;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: sensor!>operator,connected_modbus_slave;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_6(sensor, operator)=

	preconditions:
		quality:sensor,platform=N16Detector;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: sensor!>operator,connected_modbus_slave;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_7(sensor, operator)=

	preconditions:
		quality:sensor,platform=Ar41Detector;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: sensor!>operator,connected_modbus_slave;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_8(sensor, operator)=

	preconditions:
		quality:sensor,platform=conductivitySensor;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: sensor!>operator,connected_modbus_slave;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_9(sensor, operator)=

	preconditions:
		quality:sensor,platform=tempSensor;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: operator!>sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_10(sensor, operator)=

	preconditions:
		quality:sensor,platform=coolantTempSensor;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: operator!>sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_11(sensor, operator)=

	preconditions:
		quality:sensor,platform=powerSensor;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: operator!>sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_12(sensor, operator)=

	preconditions:
		quality:sensor,platform=CAM;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: operator!>sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_13(sensor, operator)=

	preconditions:
		quality:sensor,platform=periodSensor;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: operator!>sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_14(sensor, operator)=

	preconditions:
		quality:sensor,platform=N16Detector;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: operator!>sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_15(sensor, operator)=

	preconditions:
		quality:sensor,platform=Ar41Detector;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: operator!>sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.

exploit sensorMissingShutdown_16(sensor, operator)=

	preconditions:
		quality:sensor,platform=conductivitySensor;

		quality:sensor,spoofed=false;

		quality:operator,platform=operatorStation;
		quality:operator,status=ok;
		quality:operator,powerStatus=on;

		topology: operator!>sensor,connected_modbus_master;
	postconditions:
		update quality:operator,manualScram=true;
.
