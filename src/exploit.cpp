#include <vector>
#include <memory>
#include <libpq-fe.h>

#include "exploit.hpp"
#include "util_db.hpp"

using namespace std;

// static int exploit_preconds_fetch(struct List *precond_list, int sploit_id)
// {
//  	PGresult *res;
//  	int num_rows;

//  	dbtrans_begin();

//  	char sql[MAXSTRLEN+1] = {0};
//  	snprintf(sql, MAXSTRLEN, "SELECT * FROM exploit_precondition WHERE exploit_id = %d", sploit_id);
//  	res = PQexec(conn, sql);

//  	dbtrans_end();

//  	if(PQresultStatus(res) != PGRES_TUPLES_OK) {
// 		fprintf(stderr, "SELECT command failed: %s",
// 			PQerrorMessage(conn));
// 		goto fatal;
// 	}

// 	num_rows = PQntuples(res);
// 	for(int i=0; i<num_rows; i++) {
// 		int param = atoi(PQgetvalue(res, i, 1));
// 		char *property = dynstr(PQgetvalue(res, i, 2));
// 		char *value = dynstr(PQgetvalue(res, i, 3));

// 		struct ExploitPrecond *precond = malloc(sizeof(struct ExploitPrecond));
// 		precond->param = param;
// 		precond->property = property;
// 		precond->value = value;

// 		list_push(precond_list, precond);
// 	}

// 	PQclear(res);
//  	return 0;
// fatal:
// 	PQclear(res);
// 	return -1;
// }

Exploit::Exploit(std::string name, int num_params) : name(name), num_params(num_params) {};

int Exploit::fetch_all(vector<shared_ptr<Exploit> > &exploit_list)
{
	PGresult *res;
	int num_rows;

	dbtrans_begin();

	string sql = "SELECT * FROM exploit;";
	res = PQexec(conn, sql.c_str());

	dbtrans_end();

	if(PQresultStatus(res) != PGRES_TUPLES_OK) {
		fprintf(stderr, "SELECT command failed: %s",
			PQerrorMessage(conn));
		goto fatal;
	}

	num_rows = PQntuples(res);
	for (int i=0; i<num_rows; i++) {
		// int id = stoi(PQgetvalue(res, i, 0));
		string name = PQgetvalue(res, i, 1);
		int num_params = stoi(PQgetvalue(res, i, 2));

		shared_ptr<Exploit> exploit(new Exploit(name, num_params));

		exploit_list.push_back(exploit);
	}

	PQclear(res);
	return exploit_list.size();
fatal:
	PQclear(res);
	return -1;
}
