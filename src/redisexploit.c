/** \file ag_redisexploit.c
 * \author Kyle Cook <kylecook80@gmail.com>
 * \date June 2016
 * \copyright Copyright (C) The University of Tulsa - All Rights Reserved. Unauthorized copying or distribution of this file is strictly prohibited.
 *
 * Handles the putting and getting exploits in and out of the redis server.
 *
 * Each function requires a key, which is the name of the list each exploit is being put into and gotten out of to work.
 * Does the required work converting an exploits data into a string that can be stored in the redis server and vice-versa.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "redisexploit.h"
#include "exploit.h"
#include "util_redis.h"
#include "util_common.h"

#define DELIMITER ":"

/*!
 * Adds an exploit to a redis server list.
 *
 * Takes in a key that determines which list to put the exploit in, as well as an exploit.
 * It then takes the contents of the exploit and formats it so that it can be added to the redis list
 *
 * If the exploit is null it will print out to the console and return 1;
 */
int rexploit_set(const char *key, struct Exploit *exploit)
{
	char *str;

	if(exploit == NULL) {
		printf("Exploit cannot be null.");
		return 1;
	}

	str = malloc(sizeof(char)*MAXSTRLEN);
	snprintf(str, MAXSTRLEN, "%d:%s", exploit->id, exploit->name);

	redis_enqueue(key, str);
	free(str);

	return 0;
}

/*!
 * Gets the topmost value out of a redis server list.
 *
 * Takes in a key, which it then uses to fetch the details of an exploit.
 * It parses it to be put into an exploit proper which it then returns.
 *
 * If the list in redis given by the key is empty, it will return a null exploit.
 */
struct Exploit *rexploit_get(const char *key)
{
	char *str;
	char *saveptr;
	struct Exploit *exploit = {0};

	if(key == NULL)
		return NULL;

	str = redis_dequeue(key);
	if(str != NULL){
		DEBUG_PRINT("DEQUEUE Reply string is: %s\n", str);

		char *exploit_id = strtok_r(str, DELIMITER, &saveptr);
		char *exploit_name = dynstr(strtok_r(NULL, DELIMITER, &saveptr));

		exploit = calloc(1, sizeof(struct Exploit));
		exploit->id = atoi(exploit_id);
		exploit->name = exploit_name;

		free(str);
	}

	return exploit;
}
