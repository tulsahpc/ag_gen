/** \file ag_exploit.c
 * \author Kyle Cook <kylecook80@gmail.com>
 * \date June 2016
 * \copyright Copyright (C) The University of Tulsa - All Rights Reserved. Unauthorized copying or distribution of this file is strictly prohibited.
 */

#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>

#include "exploit.h"
#include "network.h"
#include "util_common.h"
#include "util_hash.h"
#include "util_list.h"
#include "util_db.h"

struct ExploitPrecond {
	int param;
	char *property;
	char *value;
};

static void exploit_precond_free(struct ExploitPrecond *precond)
{
	free(precond->property);
	free(precond->value);
	free(precond);
}

static int exploit_preconds_fetch(struct List *precond_list, int sploit_id)
{
 	PGresult *res;
 	int num_rows;

 	dbtrans_begin();

 	char sql[MAXSTRLEN+1] = {0};
 	snprintf(sql, MAXSTRLEN, "SELECT * FROM exploit_precondition WHERE exploit_id = %d", sploit_id);
 	res = PQexec(conn, sql);

 	dbtrans_end();

 	if(PQresultStatus(res) != PGRES_TUPLES_OK) {
		fprintf(stderr, "SELECT command failed: %s",
			PQerrorMessage(conn));
		goto fatal;
	}

	num_rows = PQntuples(res);
	for(int i=0; i<num_rows; i++) {
		int param = atoi(PQgetvalue(res, i, 1));
		char *property = dynstr(PQgetvalue(res, i, 2));
		char *value = dynstr(PQgetvalue(res, i, 3));

		struct ExploitPrecond *precond = malloc(sizeof(struct ExploitPrecond));
		precond->param = param;
		precond->property = property;
		precond->value = value;

		list_push(precond_list, precond);
	}

	PQclear(res);
 	return 0;
fatal:
	PQclear(res);
	return -1;
}

int exploits_fetch(struct List *exploit_list)
{
	PGresult *res;
	int num_rows;

	dbtrans_begin();

	char sql[MAXSTRLEN+1] = {0};
	snprintf(sql, MAXSTRLEN, "SELECT * FROM exploit;");
	res = PQexec(conn, sql);
	dbtrans_end();

	if(PQresultStatus(res) != PGRES_TUPLES_OK) {
		fprintf(stderr, "SELECT command failed: %s",
			PQerrorMessage(conn));
		goto fatal;
	}

	num_rows = PQntuples(res);
	for (int i=0; i<num_rows; i++) {
		int id = atoi(PQgetvalue(res, i, 0));
		char *name = dynstr(PQgetvalue(res, i, 1));
		int numParams = atoi(PQgetvalue(res, i, 2));

		struct Exploit *exploit = calloc(1, sizeof(struct Exploit));
		exploit->id = id;
		exploit->name = name;
		exploit->num_params = numParams;
		exploit->properties = list_new();

		exploit_preconds_fetch(exploit->properties, id);

		list_push(exploit_list, exploit);
	}

	PQclear(res);
	return list_size(exploit_list);
fatal:
	PQclear(res);
	return -1;
}

void exploit_print(struct Exploit *exploit)
{
	printf("exploit #%d: %s\n", exploit->id, exploit->name);
}

void exploit_free(struct Exploit *exploit)
{
	if(exploit->properties != NULL) {
		list_iterate(exploit->properties, exploit_precond_free);
		list_free(exploit->properties);
	}
	free(exploit->name);
	free(exploit);
}
