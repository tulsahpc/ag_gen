/** \file ag_redisexploit.c
 * \author Kyle Cook <kylecook80@gmail.com>
 * \date June 2016
 * \copyright Copyright (C) The University of Tulsa - All Rights Reserved. Unauthorized copying or distribution of this file is strictly prohibited.
 *
 * Handles the putting and getting exploits in and out of the redis server.
 *
 * Each function requires a key, which is the name of the list each exploit is being put into and gotten out of to work.
 * Does the required work converting an exploits data into a string that can be stored in the redis server and vice-versa.
 */

#include <string>

#include "redisexploit.h"
#include "exploit.h"
#include "util_redis.h"
#include "util_common.h"

using namespace std;

/*!
 * Adds an exploit to a redis server list.
 *
 * Takes in a key that determines which list to put the exploit in, as well as an exploit.
 * It then takes the contents of the exploit and formats it so that it can be added to the redis list
 *
 * If the exploit is null it will print out to the console and return 1;
 */
int rexploit_set(const char *key, Exploit *exploit)
{
	if(exploit == NULL) {
		printf("Exploit cannot be null.");
		return 1;
	}

	string redis_query = to_string(exploit->get_id()) + ":" + exploit->get_name() + to_string(exploit->get_num_params());
	redis_enqueue(key, redis_query.c_str());

	return 0;
}

/*!
 * Gets the topmost value out of a redis server list.
 *
 * Takes in a key, which it then uses to fetch the details of an exploit.
 * It parses it to be put into an exploit proper which it then returns.
 *
 * If the list in redis given by the key is empty, it will return a null exploit.
 */
Exploit rexploit_get(const char *key)
{
	string redis_value = redis_dequeue(key);
	vector<string> redis_parsed = split(redis_value, ':');

	int exploit_id = stoi(redis_parsed[0]);
	string exploit_name = redis_parsed[1];
	int exploit_num_params = stoi(redis_parsed[2]);

	Exploit exploit(exploit_id, exploit_name, exploit_num_params);

	return exploit;
}
