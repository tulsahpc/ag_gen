/*
 * exploit_utils.c
 *
 *  Created on: Jan 7, 2016
 *      Author: john-hale
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "identifier.h"
#include "exploit.h"
#include "globals.h"

//STRAIGHT OUTTA SEDGEWICK 'ALGORITHMS IN C', p.233
// p_M should be prime and is defined in network_state.h
// 64 is a reasonable value based on alphabet size
unsigned int param_hash(char *v) {
    unsigned int h;
    for (h = 0; *v != '\0'; v++)
        h = (64 * h + *v) % M_p;
    return h;
}

// make and populate a new param structure
struct param *new_param(char *str, struct identifier_hashtable *i_ht) {
    struct param *p = (struct param *) malloc(sizeof(struct param));
    struct identifier_hashtable_node *i_node = insert_identifier(str, PARAM, i_ht);
    p->name = i_node->i;
    return p;
}

struct param_list_node *find_param(char *str, struct param_list_node *p_list) {
    struct param_list_node *current_node = p_list;
    int done = 0;
    while (!done && current_node != NULL) {
        if (!strcmp(str, current_node->p->name->key)) { done = 1; }
        else { current_node = current_node->next; }
    }
    return current_node;
}

struct param_list_node *insert_param(char *str, struct param_list_node *p_list, struct identifier_hashtable *i_ht) {
    struct param_list_node *p_node = NULL;
    //IS THE HASH USED?
    unsigned int index = param_hash(str);
    // printf("Inside insert_param; hash is %d\n",index);
    // see if a param already exists
    // if a param does not exist, create it and return the node containing it.
    // if the param already exists, return the node containing it.
    if ((p_node = find_param(str, p_list)) == NULL) {
//		printf("insert_param: p_node is NULL\n");
        struct param *p = new_param(str, i_ht);
//		printf("insert_param: param p created = %p\n", (void *) p);
        p_node = (struct param_list_node *) malloc(sizeof(struct param_list_node));
//		printf("insert_param: p_node created = %p\n", (void *) p_node);
//		printf("insert_param: p_list before = %p\n", (void *) p_list);
        p_node->p = p;
        p_node->prev = NULL;
        p_node->next = p_list;
        if (p_list != NULL) p_list->prev = p_node;
        p_list = p_node;
//		printf("insert_param: p_list after = %p\n", (void *) p_list);
    }
    return p_node;
}

//this function seems silly, I know, but at least the plumbing is here for expansion if needed
struct param_list_node *new_param_list(struct param_list_node *parameter_list) {
    struct param_list_node *pl = NULL;
//	printf("Inside new_param_list\n");
    parameter_list = pl;
    return pl;
}

int param_fact_match(struct parameterized_fact *pf1, struct parameterized_fact *pf2) {
    if (pf1->type != pf2->type) return 0;
    if (pf1->type == P_QUALITY) return (param_quality_match(pf1->pq, pf2->pq));
    if (pf1->type == P_TOPOLOGY) return (param_topology_match(pf1->pt, pf2->pt));
    else return -1;
}

struct parameterized_fact *new_parameterized_quality(char *p, char *prop, char *val, struct param_list_node *p_list,
                                                     struct identifier_hashtable *i_ht) {
    //make the parameterized_quality
    struct parameterized_quality *p_qual = (struct parameterized_quality *) malloc(sizeof(struct parameterized_quality));
    // needs to short circuit out if parameter does not exist
    p_qual->p = (insert_param(p, p_list, i_ht))->p;
    p_qual->property = insert_and_get_identifier(prop, PROPERTY, i_ht);
    p_qual->value = insert_and_get_identifier(val, VALUE, i_ht);
    //make the fact
    struct parameterized_fact *pf = (struct parameterized_fact *) malloc(sizeof(struct parameterized_fact));
    pf->pq = p_qual;
    pf->type = P_QUALITY;
    return pf;
}

int param_quality_match(struct parameterized_quality *pq1, struct parameterized_quality *pq2) {
    if (!strcmp(pq1->p->name->key, pq2->p->name->key) &&
        !strcmp(pq1->property->key, pq2->property->key) &&
        !strcmp(pq1->value->key, pq2->value->key)) { return 1; }
    else { return 0; }
}

struct parameterized_fact *new_parameterized_topology(char *p1, char *p2, char *rel, struct param_list_node *p_list,
                                                      struct identifier_hashtable *i_ht) {
    //make the parameterized_quality
    struct parameterized_topology *p_top = (struct parameterized_topology *) malloc(sizeof(struct parameterized_topology));
    // needs to short circuit out if parameter does not exist
    p_top->p1 = (insert_param(p1, p_list, i_ht))->p;
    p_top->p2 = (insert_param(p2, p_list, i_ht))->p;
    p_top->relationship = insert_and_get_identifier(rel, RELATIONSHIP, i_ht);
    //make the fact
    struct parameterized_fact *pf = (struct parameterized_fact *) malloc(sizeof(struct parameterized_fact));
    pf->pt = p_top;
    pf->type = P_TOPOLOGY;
    return pf;
}

int param_topology_match(struct parameterized_topology *pt1, struct parameterized_topology *pt2) {
    if (!strcmp(pt1->p1->name->key, pt2->p1->name->key) &&
        !strcmp(pt1->p2->name->key, pt2->p2->name->key) &&
        !strcmp(pt1->relationship->key, pt2->relationship->key)) { return 1; }
    else { return 0; }
}

struct precondition *new_precondition(struct parameterized_fact *pf) {
    struct precondition *pre = (struct precondition *) malloc(sizeof(struct precondition));
    pre->pf = pf;
    return pre;
}

// a precondition list must be non-empty
struct precondition_list_node *new_precondition_list(struct precondition *pre) {
    struct precondition_list_node *p_list = (struct precondition_list_node *) malloc(
            sizeof(struct precondition_list_node));
    p_list->pre = pre;
    p_list->next = NULL;
    p_list->prev = NULL;
    return p_list;
}

//TO DO
struct precondition_list_node *find_precondition(struct precondition *pre, struct precondition_list_node *pre_list) {
    struct precondition_list_node *current_node = pre_list;
    int done = 0;
    while (!done && current_node != NULL) {
        //LOGIC: P_FACTS MUST MATCH
        if (param_fact_match(pre->pf, current_node->pre->pf)) { done = 1; }
        else { current_node = current_node->next; }
    }
    return current_node;
}

struct precondition_list_node *insert_precondition(struct precondition *pre, struct precondition_list_node *p_list) {
    struct precondition_list_node *pre_node = NULL;
// see if a precondition already exists
// if a precondition does not exist, create it and return the node containing it.
// if the precondition already exists, return the node containing it.
    if ((pre_node = find_precondition(pre, p_list)) == NULL) {
        pre_node = (struct precondition_list_node *) malloc(sizeof(struct precondition_list_node));
        pre_node->pre = pre;
        pre_node->prev = NULL;
        pre_node->next = p_list;
        p_list->prev = pre_node;
        p_list = pre_node;
    }
    return pre_node;
}

struct postcondition *new_postcondition(int command, struct parameterized_fact *pf) {
    struct postcondition *post = (struct postcondition *) malloc(sizeof(struct postcondition));
    post->command = command;
    post->pf = pf;
    return post;
}

// a postcondition list must be non-empty
struct postcondition_list_node *new_postcondition_list(struct postcondition *post) {
    struct postcondition_list_node *p_list = (struct postcondition_list_node *) malloc(
            sizeof(struct postcondition_list_node));
    p_list->post = post;
    p_list->next = NULL;
    p_list->prev = NULL;
    return p_list;
}

//TO DO
struct postcondition_list_node *find_postcondition(struct postcondition *post,
                                                   struct postcondition_list_node *post_list) {
    struct postcondition_list_node *current_node = post_list;
    int done = 0;
    while (!done && current_node != NULL) {
        // POST CHECK LOGIC
        // COMMANDS MUST MATCH AND P_FACTS MUST MATCH
        if (post->command == current_node->post->command &&
            param_fact_match(post->pf, current_node->post->pf)) { done = 1; }
        else { current_node = current_node->next; }
    }
    return current_node;
}

struct postcondition_list_node *insert_postcondition(struct postcondition *post,
                                                     struct postcondition_list_node *post_list) {
    struct postcondition_list_node *post_node = NULL;
// see if a postcondition already exists
// if a postcondition does not exist, create it and return the node containing it.
// if the postcondition already exists, return the node containing it.
    if ((post_node = find_postcondition(post, post_list)) == NULL) {
        post_node = (struct postcondition_list_node *) malloc(sizeof(struct postcondition_list_node));
        post_node->post = post;
        post_node->prev = NULL;
        post_node->next = post_list;
        post_list->prev = post_node;
        post_list = post_node;
    }
    return post_node;
}

struct exploit *new_exploit(char *str, struct param_list_node *param_ln, struct precondition_list_node *pre_ln,
                            struct postcondition_list_node *post_ln, struct identifier_hashtable *i_ht) {
    //see if the identifier exists
    struct identifier_hashtable_node *i_node = find_identifier(str, XPLOIT, i_ht);
    struct exploit *e = NULL;
    if (i_node == NULL) {
//		printf("new_exploit: adding a new identifier for the exploit name\n");
        i_node = add_new_identifier(str, XPLOIT, i_ht);
        e = (struct exploit *) malloc(sizeof(struct exploit));
        e->name = i_node->i;
        e->param_list = param_ln;
        e->pre_list = pre_ln;
        e->post_list = post_ln;
    }
//	printf("new_exploit: returning e=%p\n",(void *) e);
    return e;
}

// an exploit list must be non-empty
struct exploit_list_node *new_exploit_list(struct exploit *e) {
    struct exploit_list_node *e_ln = (struct exploit_list_node *) malloc(sizeof(struct exploit_list_node));
    e_ln->e = e;
    e_ln->prev = NULL;
    e_ln->next = NULL;
//	printf("new_exploit_list: e_ln = %p\n",(void *) e_ln);
    return e_ln;
}

struct exploit_list_node *find_exploit(struct exploit *e, struct exploit_list_node *e_list) {
    struct exploit_list_node *current_node = e_list;
    int done = 0;
    while (!done && current_node != NULL) {
        if (!strcmp(e->name->key, current_node->e->name->key)) { done = 1; }
        else { current_node = current_node->next; }
    }
    return current_node;
}

// the key of an exploit is its name
//insert_exploit returns the head of the exploit_list
struct exploit_list_node *insert_exploit(struct exploit *e, struct exploit_list_node *e_list) {
    struct exploit_list_node *e_node;
// see if an exploit already exists
// if an exploit does not exist, create it and return the node containing it.
// if the exploit already exists, return the node containing it.
    if ((e_node = find_exploit(e, e_list)) == NULL) {
        e_node = (struct exploit_list_node *) malloc(sizeof(struct exploit_list_node));
        e_node->e = e;
        e_node->prev = NULL;
        e_node->next = e_list;
        if (e_list != NULL) e_list->prev = e_node;
        e_list = e_node;
    }
    return e_list;
}

char *exploit_list_to_string(struct exploit_list_node *el) {
    struct exploit_list_node *current_en_pointer = el;
    struct param_list_node *current_param_pointer;
    struct precondition_list_node *current_pre_pointer;
    struct postcondition_list_node *current_post_pointer;
    char *str;
    asprintf(&str, "Exploit List %p\n", (void *) el);
    while (current_en_pointer != NULL) {
        asprintf(&str, "%sEXPLOIT NAME:%s\nPARAMETERS ", str, current_en_pointer->e->name->key);
        current_param_pointer = current_en_pointer->e->param_list;
        while (current_param_pointer != NULL) {
            asprintf(&str, "%s %s ", str, current_param_pointer->p->name->key);
            current_param_pointer = current_param_pointer->next;
        }
        asprintf(&str, "%s\n", str);
        current_pre_pointer = current_en_pointer->e->pre_list;
        asprintf(&str, "%sPRECONDITIONS\n", str);
        while (current_pre_pointer != NULL) {
            if (current_pre_pointer->pre->pf->type == P_QUALITY) {
                asprintf(&str, "%sQ: a=%s p=%s v=%s\n", str, current_pre_pointer->pre->pf->pq->p->name->key,
                         current_pre_pointer->pre->pf->pq->property->key, current_pre_pointer->pre->pf->pq->value->key);
            }
            else if (current_pre_pointer->pre->pf->type == P_TOPOLOGY) {
                asprintf(&str, "%sT: a1=%s a2=%s r=%s\n", str, current_pre_pointer->pre->pf->pt->p1->name->key,
                         current_pre_pointer->pre->pf->pt->p2->name->key,
                         current_pre_pointer->pre->pf->pt->relationship->key);

            }
            current_pre_pointer = current_pre_pointer->next;
        }
        asprintf(&str, "%sPOSTCONDITIONS\n", str);
        current_post_pointer = current_en_pointer->e->post_list;
        while (current_post_pointer != NULL) {
            if (current_post_pointer->post->command == INS) asprintf(&str, "%sINS ", str);
            else if (current_post_pointer->post->command == DEL) asprintf(&str, "%sDEL ", str);
            if (current_post_pointer->post->pf->type == P_QUALITY) {
                asprintf(&str, "%sQ: a=%s p=%s v=%s\n", str, current_post_pointer->post->pf->pq->p->name->key,
                         current_post_pointer->post->pf->pq->property->key,
                         current_post_pointer->post->pf->pq->value->key);
            }
            else if (current_post_pointer->post->pf->type == P_TOPOLOGY) {
                asprintf(&str, "%sT: a1=%s a2=%s r=%s\n", str, current_post_pointer->post->pf->pt->p1->name->key,
                         current_post_pointer->post->pf->pt->p2->name->key,
                         current_post_pointer->post->pf->pt->relationship->key);

            }
            current_post_pointer = current_post_pointer->next;
        }
        asprintf(&str, "%s\n", str);
        current_en_pointer = current_en_pointer->next;
    }
    return str;
}
